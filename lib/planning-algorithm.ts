/**
 * Planning Algorithm - Core Run Suggestion Generator
 *
 * This module implements the intelligent run suggestion algorithm that is the core
 * value proposition of RainCheck. It takes weather forecasts, training plan requirements,
 * and weather preferences as inputs, then generates optimal run suggestions.
 *
 * Algorithm Rules:
 * 1. Long runs MUST be on weekends (Saturday or Sunday) only
 * 2. Long runs are always scheduled regardless of weather (they're too important to skip)
 * 3. After a long run, 2 rest days are enforced
 * 4. After an easy run, 1 rest day is enforced
 * 5. Hourly weather is used to find the best time window for each run
 * 6. Time windows: 9am-5pm for easy runs, 9am-2pm for long runs (Ireland winter daylight)
 *
 * @example
 * ```typescript
 * import { generateSuggestions } from '@/lib/planning-algorithm';
 *
 * const suggestions = generateSuggestions({
 *   forecast: weatherData,
 *   trainingPlan: currentWeekPlan,
 *   preferences: weatherPreferences,
 *   existingRuns: [],
 * });
 * ```
 */

import type { RunType, TrainingPlan, WeatherPreference } from "@prisma/client";
import type { WeatherData, HourlyWeather } from "@/types/weather";
import {
  getWeatherScore,
  toWeatherPreferenceThresholds,
  type WeatherDataForScoring,
} from "./weather-preferences";

// Re-export RunType for convenience
export { RunType } from "@prisma/client";

// Time window constants (Ireland winter daylight hours)
const EASY_RUN_START_HOUR = 9; // 9am
const EASY_RUN_END_HOUR = 17; // 5pm (run should end by this time)
const LONG_RUN_START_HOUR = 9; // 9am
const LONG_RUN_END_HOUR = 14; // 2pm (run should end by this time)

// Rest day constants
const REST_DAYS_AFTER_LONG_RUN = 2;
const REST_DAYS_AFTER_EASY_RUN = 1;

/**
 * Input parameters for the planning algorithm.
 */
export interface AlgorithmInput {
  /** Array of daily weather forecasts with hourly data */
  forecast: WeatherData[];
  /** Current week's training plan (optional - algorithm works without it) */
  trainingPlan: TrainingPlan | null;
  /** Weather preferences for each run type */
  preferences: WeatherPreference[];
  /** Already scheduled runs to avoid conflicts */
  existingRuns: Array<{ date: Date | string; runType: RunType }>;
}

/**
 * Time range for a suggested run
 */
export interface TimeRange {
  start: string; // "9am"
  end: string; // "11am"
}

/**
 * Weather summary included in each suggestion.
 */
export interface WeatherSummary {
  condition: string;
  temperature: number;
  precipitation: number;
  windSpeed: number;
}

/**
 * A run suggestion generated by the algorithm.
 */
export interface Suggestion {
  /** Date for the suggested run */
  date: Date;
  /** Type of run to do on this day */
  runType: RunType;
  /** Suggested distance in km */
  distance: number;
  /** Weather quality score (0-100) for the suggested time window */
  weatherScore: number;
  /** True if score >= 80 (excellent conditions) */
  isOptimal: boolean;
  /** Human-readable explanation for this suggestion */
  reason: string;
  /** Weather data for the suggested time window */
  weather: WeatherSummary;
  /** Suggested time range for the run */
  timeRange: TimeRange;
}

/**
 * Internal structure for scored time windows.
 */
interface ScoredTimeWindow {
  date: Date;
  dateKey: string;
  startHour: number;
  endHour: number;
  score: number;
  weather: WeatherSummary;
}

/**
 * Format a date as YYYY-MM-DD for consistent comparisons.
 */
export function formatDateKey(date: Date | string): string {
  const d = typeof date === "string" ? new Date(date) : date;
  return d.toISOString().split("T")[0]!;
}

/**
 * Add days to a date and return a new Date object.
 */
export function addDays(date: Date, days: number): Date {
  const result = new Date(date);
  result.setDate(result.getDate() + days);
  return result;
}

/**
 * Get the day name for a date.
 */
export function getDayName(date: Date): string {
  const days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
  return days[date.getDay()]!;
}

/**
 * Check if a date is a weekend (Saturday or Sunday).
 */
export function isWeekend(date: Date): boolean {
  const day = date.getDay();
  return day === 0 || day === 6; // 0 = Sunday, 6 = Saturday
}

/**
 * Check if a date is a Sunday.
 */
export function isSunday(date: Date): boolean {
  return date.getDay() === 0;
}

/**
 * Format hour to readable string (e.g., 9 -> "9am", 14 -> "2pm")
 */
export function formatHour(hour: number): string {
  if (hour === 0) return "12am";
  if (hour === 12) return "12pm";
  if (hour < 12) return `${hour}am`;
  return `${hour - 12}pm`;
}

/**
 * Get the weather preference for a specific run type.
 */
function getPreferenceForRunType(
  preferences: WeatherPreference[],
  runType: RunType
): WeatherPreference | undefined {
  return preferences.find((p) => p.runType === runType);
}

/**
 * Calculate runs needed for a training week.
 */
function getRunsNeeded(trainingPlan: TrainingPlan | null): {
  longRunDistance: number;
  easyRunDistance: number;
  totalEasyRuns: number;
} {
  if (!trainingPlan) {
    return {
      longRunDistance: 12,
      easyRunDistance: 6,
      totalEasyRuns: 3,
    };
  }

  const longRunDistance = trainingPlan.longRunTarget;
  const remainingMileage = trainingPlan.weeklyMileageTarget - longRunDistance;
  const totalEasyRuns = remainingMileage > 15 ? 3 : 2;
  const easyRunDistance = Math.round((remainingMileage / totalEasyRuns) * 10) / 10;

  return {
    longRunDistance,
    easyRunDistance,
    totalEasyRuns,
  };
}

/**
 * Score a time window using hourly weather data.
 * Returns the average score for hours in the window.
 */
function scoreTimeWindow(
  hourlyData: HourlyWeather[],
  startHour: number,
  endHour: number,
  preferences: WeatherPreference[],
  runType: RunType
): { score: number; weather: WeatherSummary } {
  const preference = getPreferenceForRunType(preferences, runType);
  const thresholds = preference ? toWeatherPreferenceThresholds(preference) : null;

  // Filter hours within the window
  const windowHours = hourlyData.filter((h) => {
    const hour = h.time.getHours();
    return hour >= startHour && hour < endHour;
  });

  if (windowHours.length === 0) {
    return {
      score: 50,
      weather: { condition: "Unknown", temperature: 10, precipitation: 50, windSpeed: 20 },
    };
  }

  // Calculate average weather for the window
  const avgTemp = windowHours.reduce((sum, h) => sum + h.temperature, 0) / windowHours.length;
  const avgPrecip = windowHours.reduce((sum, h) => sum + h.precipitation, 0) / windowHours.length;
  const avgWind = windowHours.reduce((sum, h) => sum + h.windSpeed, 0) / windowHours.length;
  const avgHumidity = windowHours.reduce((sum, h) => sum + h.humidity, 0) / windowHours.length;

  // Use the most common condition in the window
  const conditionCounts = new Map<string, number>();
  windowHours.forEach((h) => {
    conditionCounts.set(h.condition, (conditionCounts.get(h.condition) || 0) + 1);
  });
  let mostCommonCondition = "Unknown";
  let maxCount = 0;
  conditionCounts.forEach((count, condition) => {
    if (count > maxCount) {
      maxCount = count;
      mostCommonCondition = condition;
    }
  });

  const weatherForScoring: WeatherDataForScoring = {
    condition: mostCommonCondition,
    temperature: avgTemp,
    feelsLike: avgTemp,
    precipitation: avgPrecip,
    humidity: avgHumidity,
    windSpeed: avgWind,
  };

  const score = thresholds ? getWeatherScore(weatherForScoring, thresholds) : 50;

  return {
    score: Math.round(score),
    weather: {
      condition: mostCommonCondition,
      temperature: Math.round(avgTemp),
      precipitation: Math.round(avgPrecip),
      windSpeed: Math.round(avgWind),
    },
  };
}

/**
 * Find the best time window for a run on a given day.
 */
function findBestTimeWindow(
  dayWeather: WeatherData,
  preferences: WeatherPreference[],
  runType: RunType
): ScoredTimeWindow | null {
  const isLongRun = runType === "LONG_RUN";
  const startHour = isLongRun ? LONG_RUN_START_HOUR : EASY_RUN_START_HOUR;
  const endHour = isLongRun ? LONG_RUN_END_HOUR : EASY_RUN_END_HOUR;

  // If no hourly data, use daily data
  if (!dayWeather.hourly || dayWeather.hourly.length === 0) {
    const preference = getPreferenceForRunType(preferences, runType);
    const thresholds = preference ? toWeatherPreferenceThresholds(preference) : null;
    const weatherForScoring: WeatherDataForScoring = {
      condition: dayWeather.condition,
      temperature: dayWeather.temperature,
      feelsLike: dayWeather.feelsLike,
      precipitation: dayWeather.precipitation,
      humidity: dayWeather.humidity,
      windSpeed: dayWeather.windSpeed,
    };
    const score = thresholds ? getWeatherScore(weatherForScoring, thresholds) : 50;

    return {
      date: dayWeather.datetime,
      dateKey: formatDateKey(dayWeather.datetime),
      startHour,
      endHour,
      score: Math.round(score),
      weather: {
        condition: dayWeather.condition,
        temperature: Math.round(dayWeather.temperature),
        precipitation: Math.round(dayWeather.precipitation),
        windSpeed: Math.round(dayWeather.windSpeed),
      },
    };
  }

  // Try different 2-hour windows within the allowed time range and find the best
  let bestWindow: ScoredTimeWindow | null = null;
  let bestScore = -1;

  // Window size: 2 hours for easy runs, 3 hours for long runs
  const windowSize = isLongRun ? 3 : 2;

  for (let windowStart = startHour; windowStart <= endHour - windowSize; windowStart++) {
    const { score, weather } = scoreTimeWindow(
      dayWeather.hourly,
      windowStart,
      windowStart + windowSize,
      preferences,
      runType
    );

    if (score > bestScore) {
      bestScore = score;
      bestWindow = {
        date: dayWeather.datetime,
        dateKey: formatDateKey(dayWeather.datetime),
        startHour: windowStart,
        endHour: windowStart + windowSize,
        score,
        weather,
      };
    }
  }

  // If no window found, return full range
  if (!bestWindow) {
    const { score, weather } = scoreTimeWindow(
      dayWeather.hourly,
      startHour,
      endHour,
      preferences,
      runType
    );
    return {
      date: dayWeather.datetime,
      dateKey: formatDateKey(dayWeather.datetime),
      startHour,
      endHour,
      score,
      weather,
    };
  }

  return bestWindow;
}

/**
 * Generate human-readable reasoning for a suggestion.
 */
function generateReason(runType: RunType, score: number, weather: WeatherSummary): string {
  const quality =
    score >= 80 ? "excellent" : score >= 60 ? "good" : score >= 40 ? "fair" : "challenging";

  if (runType === "LONG_RUN") {
    if (score >= 60) {
      return `Best weekend conditions for your long run (${score}/100). ${weather.condition}, ${weather.temperature}°C with ${weather.precipitation}% precipitation chance.`;
    }
    return `Scheduled for weekend as required. ${weather.condition} with ${weather.precipitation}% precipitation chance. Consider adjusting pace if needed.`;
  }

  return `${quality.charAt(0).toUpperCase() + quality.slice(1)} conditions (${score}/100). ${weather.condition}, ${weather.temperature}°C.`;
}

/**
 * Create a suggestion from a scored time window.
 */
function createSuggestion(
  window: ScoredTimeWindow,
  runType: RunType,
  distance: number
): Suggestion {
  return {
    date: window.date,
    runType,
    distance,
    weatherScore: window.score,
    isOptimal: window.score >= 80,
    reason: generateReason(runType, window.score, window.weather),
    weather: window.weather,
    timeRange: {
      start: formatHour(window.startHour),
      end: formatHour(window.endHour),
    },
  };
}

/**
 * Generate optimal run suggestions based on weather and training plan.
 *
 * Rules:
 * - Long runs: Weekend only, always scheduled, 2-day rest after
 * - Easy runs: Best hourly weather, 1-day rest after
 * - Generates 5-6 suggestions with at least 2 long runs (requires 14 days of forecast)
 */
export function generateSuggestions(input: AlgorithmInput): Suggestion[] {
  const { forecast, trainingPlan, preferences, existingRuns } = input;

  if (forecast.length === 0) {
    return [];
  }

  const runsNeeded = getRunsNeeded(trainingPlan);
  const existingRunDates = new Set<string>(existingRuns.map((run) => formatDateKey(run.date)));
  const suggestions: Suggestion[] = [];
  const usedDates = new Set<string>();
  const restDates = new Set<string>(); // Dates that must be rest days

  // Step 1: Find all weekend days for long runs
  const weekendDays = forecast.filter((day) => isWeekend(day.datetime));

  // Sort weekend days: prefer Sunday, then by weather score
  const scoredWeekends = weekendDays
    .map((day) => {
      const window = findBestTimeWindow(day, preferences, "LONG_RUN");
      return { day, window };
    })
    .filter((item) => item.window !== null)
    .sort((a, b) => {
      // First, group by week (days within 7 days of each other)
      // Then within each week, prefer Sunday over Saturday
      // Then prefer better weather
      const aIsSunday = isSunday(a.day.datetime);
      const bIsSunday = isSunday(b.day.datetime);

      if (aIsSunday && !bIsSunday) return -1;
      if (bIsSunday && !aIsSunday) return 1;
      return b.window!.score - a.window!.score;
    });

  // Step 2: Schedule long runs on weekends (aim for 2 long runs across 14 days)
  // One long run per weekend
  const scheduledWeekends = new Set<number>(); // Track which "week number" has a long run

  for (const { day, window } of scoredWeekends) {
    if (!window) continue;

    const dateKey = formatDateKey(day.datetime);
    if (existingRunDates.has(dateKey) || usedDates.has(dateKey) || restDates.has(dateKey)) {
      continue;
    }

    // Calculate week number (0 = first week, 1 = second week, etc.)
    const daysSinceStart = Math.floor(
      (day.datetime.getTime() - forecast[0]!.datetime.getTime()) / (1000 * 60 * 60 * 24)
    );
    const weekNum = Math.floor(daysSinceStart / 7);

    // Only one long run per weekend/week
    if (scheduledWeekends.has(weekNum)) continue;

    // Schedule this long run
    suggestions.push(createSuggestion(window, "LONG_RUN", runsNeeded.longRunDistance));
    usedDates.add(dateKey);
    scheduledWeekends.add(weekNum);

    // Mark 2 rest days after the long run
    for (let i = 1; i <= REST_DAYS_AFTER_LONG_RUN; i++) {
      const restDay = addDays(day.datetime, i);
      restDates.add(formatDateKey(restDay));
    }

    // Stop after 2 long runs
    if (suggestions.filter((s) => s.runType === "LONG_RUN").length >= 2) {
      break;
    }
  }

  // Step 3: Schedule easy runs on weekdays
  // Find all non-weekend, non-rest days
  const availableDays = forecast.filter((day) => {
    const dateKey = formatDateKey(day.datetime);
    return (
      !isWeekend(day.datetime) &&
      !existingRunDates.has(dateKey) &&
      !usedDates.has(dateKey) &&
      !restDates.has(dateKey)
    );
  });

  // Score all available days
  const scoredDays = availableDays
    .map((day) => ({
      day,
      window: findBestTimeWindow(day, preferences, "EASY_RUN"),
    }))
    .filter((item) => item.window !== null)
    .sort((a, b) => b.window!.score - a.window!.score);

  // Schedule easy runs with 1-day rest between them
  let easyRunsScheduled = 0;
  const targetEasyRuns = Math.max(runsNeeded.totalEasyRuns, 4); // At least 4 easy runs for 5-6 total

  for (const { day, window } of scoredDays) {
    if (!window) continue;
    if (easyRunsScheduled >= targetEasyRuns) break;

    const dateKey = formatDateKey(day.datetime);

    // Check if this day is now a rest day (could have been marked by earlier easy run)
    if (restDates.has(dateKey)) continue;

    // Schedule this easy run
    suggestions.push(createSuggestion(window, "EASY_RUN", runsNeeded.easyRunDistance));
    usedDates.add(dateKey);
    easyRunsScheduled++;

    // Mark 1 rest day after the easy run
    const restDay = addDays(day.datetime, REST_DAYS_AFTER_EASY_RUN);
    restDates.add(formatDateKey(restDay));
  }

  // Sort suggestions by date
  suggestions.sort((a, b) => a.date.getTime() - b.date.getTime());

  return suggestions;
}

/**
 * Calculate the gap in days between two dates.
 */
export function getDayGap(date1: Date, date2: Date): number {
  const diffTime = Math.abs(date2.getTime() - date1.getTime());
  return Math.floor(diffTime / (1000 * 60 * 60 * 24));
}

/**
 * Validate that no hard days are back-to-back.
 */
export function validateNoBackToBackHardDays(suggestions: Suggestion[]): boolean {
  const hardRunTypes: RunType[] = ["LONG_RUN", "TEMPO_RUN", "INTERVAL_RUN"];
  const sorted = [...suggestions].sort((a, b) => a.date.getTime() - b.date.getTime());

  for (let i = 0; i < sorted.length - 1; i++) {
    const current = sorted[i]!;
    const next = sorted[i + 1]!;
    const gap = getDayGap(current.date, next.date);

    if (gap === 1) {
      const currentIsHard = hardRunTypes.includes(current.runType);
      const nextIsHard = hardRunTypes.includes(next.runType);
      if (currentIsHard && nextIsHard) return false;
    }
  }

  return true;
}

/**
 * Validate that there are no large gaps (5+ days) between suggestions.
 */
export function validateNoLargeGaps(suggestions: Suggestion[]): boolean {
  if (suggestions.length < 2) return true;

  const sorted = [...suggestions].sort((a, b) => a.date.getTime() - b.date.getTime());

  for (let i = 0; i < sorted.length - 1; i++) {
    const current = sorted[i]!;
    const next = sorted[i + 1]!;
    const gap = getDayGap(current.date, next.date);

    if (gap >= 5) return false;
  }

  return true;
}
