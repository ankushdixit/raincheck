/**
 * Planning Algorithm - Core Run Suggestion Generator
 *
 * This module implements the intelligent run suggestion algorithm that is the core
 * value proposition of RainCheck. It takes weather forecasts, training plan requirements,
 * and weather preferences as inputs, then generates optimal run suggestions.
 *
 * Algorithm Stages:
 * 1. Gather Requirements - Load training plan data and determine required runs
 * 2. Score Weather - Calculate weather scores for each day in the forecast period
 * 3. Place Long Run - Assign long run to the best weather day
 * 4. Place Other Runs - Distribute easy runs with proper spacing and gap prevention
 * 5. Generate Reasoning - Create human-readable explanations for each suggestion
 *
 * Key Constraints:
 * - Long runs get the best weather days (highest priority)
 * - No back-to-back hard days (long run or tempo/intervals)
 * - Rest day after long runs is enforced
 * - Maximum 4-day gap between runs to prevent detraining
 *
 * @example
 * ```typescript
 * import { generateSuggestions } from '@/lib/planning-algorithm';
 *
 * const suggestions = generateSuggestions({
 *   forecast: weatherData,
 *   trainingPlan: currentWeekPlan,
 *   preferences: weatherPreferences,
 *   existingRuns: [],
 * });
 * ```
 */

import type { RunType, TrainingPlan, WeatherPreference } from "@prisma/client";
import type { WeatherData } from "@/types/weather";
import {
  getWeatherScore,
  getWeatherQuality,
  toWeatherPreferenceThresholds,
  type WeatherDataForScoring,
  type WeatherQuality,
} from "./weather-preferences";

// Re-export RunType for convenience
export { RunType } from "@prisma/client";

/**
 * Input parameters for the planning algorithm.
 */
export interface AlgorithmInput {
  /** Array of daily weather forecasts for the planning period */
  forecast: WeatherData[];
  /** Current week's training plan (optional - algorithm works without it) */
  trainingPlan: TrainingPlan | null;
  /** Weather preferences for each run type */
  preferences: WeatherPreference[];
  /** Already scheduled runs to avoid conflicts (dates as ISO strings or Date objects) */
  existingRuns: Array<{ date: Date | string; runType: RunType }>;
}

/**
 * Weather summary included in each suggestion.
 */
export interface WeatherSummary {
  condition: string;
  temperature: number;
  precipitation: number;
  windSpeed: number;
}

/**
 * A run suggestion generated by the algorithm.
 */
export interface Suggestion {
  /** Date for the suggested run */
  date: Date;
  /** Type of run to do on this day */
  runType: RunType;
  /** Suggested distance in km */
  distance: number;
  /** Weather quality score (0-100) */
  weatherScore: number;
  /** True if score >= 80 (excellent conditions) */
  isOptimal: boolean;
  /** Human-readable explanation for this suggestion */
  reason: string;
  /** Weather data for the day */
  weather: WeatherSummary;
}

/**
 * Internal structure for tracking day weather scores.
 */
interface ScoredDay {
  date: Date;
  dateKey: string; // YYYY-MM-DD format for comparisons
  weather: WeatherData;
  score: number;
  quality: WeatherQuality;
}

/**
 * Internal structure for runs needed in a training week.
 */
interface RunsNeeded {
  longRunDistance: number;
  easyRunDistance: number;
  totalEasyRuns: number;
}

/**
 * Reasoning templates for different run types and conditions.
 */
const REASON_TEMPLATES = {
  longRun: {
    excellent:
      "Best weather of the week (score: {score}/100). {condition}, {temp}°C with {precip}% precipitation chance.",
    good: "Good conditions for your long run. {condition} with manageable {windSpeed} km/h winds.",
    fair: "Not ideal, but best available day. Consider starting early to avoid {condition}.",
    poor: "All days have challenging weather. This day is least problematic. Consider indoor alternatives.",
  },
  easyRun: {
    excellent: "{dayName} offers excellent conditions ({score}/100). {condition}, {temp}°C.",
    good: "{dayName} has good conditions ({score}/100). {condition}, {temp}°C.",
    fair: "{dayName} has fair conditions ({score}/100). {condition}, {temp}°C.",
    poor: "{dayName} has poor conditions ({score}/100). {condition}, {temp}°C.",
    gapFiller:
      "Scheduled to maintain training consistency (avoiding 4+ day gap). {condition}, {temp}°C.",
  },
  restDay: "Rest day - recovery after long run.",
} as const;

/**
 * Days of the week for reasoning templates.
 */
const DAY_NAMES = [
  "Sunday",
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
] as const;

/**
 * Format a date as YYYY-MM-DD for consistent comparisons.
 */
export function formatDateKey(date: Date | string): string {
  const d = typeof date === "string" ? new Date(date) : date;
  return d.toISOString().split("T")[0]!;
}

/**
 * Add days to a date and return a new Date object.
 */
export function addDays(date: Date, days: number): Date {
  const result = new Date(date);
  result.setDate(result.getDate() + days);
  return result;
}

/**
 * Get the day name (Sunday, Monday, etc.) for a date.
 */
export function getDayName(date: Date): string {
  return DAY_NAMES[date.getDay()]!;
}

/**
 * Get the weather preference for a specific run type.
 */
export function getPreferenceForRunType(
  preferences: WeatherPreference[],
  runType: RunType
): WeatherPreference | undefined {
  return preferences.find((p) => p.runType === runType);
}

/**
 * Calculate runs needed for a training week.
 *
 * Based on training plan:
 * - 1 long run (distance from plan)
 * - 2-3 easy runs (distance calculated from weekly mileage minus long run)
 */
export function getRunsNeeded(trainingPlan: TrainingPlan | null): RunsNeeded {
  if (!trainingPlan) {
    // Default values if no training plan
    return {
      longRunDistance: 12,
      easyRunDistance: 6,
      totalEasyRuns: 2,
    };
  }

  const longRunDistance = trainingPlan.longRunTarget;
  const remainingMileage = trainingPlan.weeklyMileageTarget - longRunDistance;

  // Typical structure: 2-3 easy runs to fill remaining mileage
  // If remaining mileage is high (>15km), use 3 easy runs; otherwise 2
  const totalEasyRuns = remainingMileage > 15 ? 3 : 2;
  const easyRunDistance = Math.round((remainingMileage / totalEasyRuns) * 10) / 10;

  return {
    longRunDistance,
    easyRunDistance,
    totalEasyRuns,
  };
}

/**
 * Score all forecast days using weather preferences for long runs.
 */
export function scoreForecastDays(
  forecast: WeatherData[],
  preferences: WeatherPreference[]
): ScoredDay[] {
  const longRunPreference = getPreferenceForRunType(preferences, "LONG_RUN");

  if (!longRunPreference) {
    // If no long run preference, use a sensible default
    return forecast.map((weather) => ({
      date: weather.datetime,
      dateKey: formatDateKey(weather.datetime),
      weather,
      score: 50, // Neutral score without preferences
      quality: "fair" as WeatherQuality,
    }));
  }

  const thresholds = toWeatherPreferenceThresholds(longRunPreference);

  return forecast.map((weather) => {
    const weatherForScoring: WeatherDataForScoring = {
      condition: weather.condition,
      temperature: weather.temperature,
      feelsLike: weather.feelsLike,
      precipitation: weather.precipitation,
      humidity: weather.humidity,
      windSpeed: weather.windSpeed,
    };

    const score = getWeatherScore(weatherForScoring, thresholds);
    const quality = getWeatherQuality(score);

    return {
      date: weather.datetime,
      dateKey: formatDateKey(weather.datetime),
      weather,
      score,
      quality,
    };
  });
}

/**
 * Find the best day for a long run from scored days.
 *
 * Excludes:
 * - Days that already have existing runs
 * - Days already used in the current planning session
 */
export function findBestLongRunDay(
  scoredDays: ScoredDay[],
  existingRunDates: Set<string>,
  usedDates: Set<string>
): ScoredDay | null {
  // Sort by score descending, then by date (prefer weekends for long runs)
  const availableDays = scoredDays
    .filter((day) => !existingRunDates.has(day.dateKey) && !usedDates.has(day.dateKey))
    .sort((a, b) => {
      // Primary sort: higher score first
      if (b.score !== a.score) {
        return b.score - a.score;
      }
      // Secondary sort: prefer weekend days (0 = Sunday, 6 = Saturday)
      const aIsWeekend = a.date.getDay() === 0 || a.date.getDay() === 6;
      const bIsWeekend = b.date.getDay() === 0 || b.date.getDay() === 6;
      if (bIsWeekend && !aIsWeekend) return 1;
      if (aIsWeekend && !bIsWeekend) return -1;
      return 0;
    });

  return availableDays[0] ?? null;
}

/**
 * Find days for easy runs that satisfy:
 * - Not already used (existing runs or this session)
 * - Proper spacing from long run day
 * - No gaps of 4+ days
 */
export function findEasyRunDays(
  scoredDays: ScoredDay[],
  longRunDateKey: string | null,
  existingRunDates: Set<string>,
  usedDates: Set<string>,
  totalEasyRuns: number
): ScoredDay[] {
  // Get all available days (not used, not long run day, not rest day after long run)
  const restDayKey = longRunDateKey ? formatDateKey(addDays(new Date(longRunDateKey), 1)) : null;

  let availableDays = scoredDays.filter(
    (day) =>
      !existingRunDates.has(day.dateKey) &&
      !usedDates.has(day.dateKey) &&
      day.dateKey !== longRunDateKey &&
      day.dateKey !== restDayKey
  );

  // Sort by score descending
  availableDays = availableDays.sort((a, b) => b.score - a.score);

  // Select easy run days, ensuring no 4+ day gaps
  const selectedDays: ScoredDay[] = [];

  // Build a set of all run dates (existing + long run)
  const allRunDates = new Set([...existingRunDates, ...usedDates]);
  if (longRunDateKey) {
    allRunDates.add(longRunDateKey);
  }

  // Sort all days by date for gap checking
  const sortedAllDays = [...scoredDays].sort((a, b) => a.date.getTime() - b.date.getTime());

  for (let i = 0; i < totalEasyRuns && availableDays.length > 0; i++) {
    // Find the best day that doesn't create a 4+ day gap
    const dayToAdd = findDayWithoutLargeGap(
      availableDays,
      [...allRunDates, ...selectedDays.map((d) => d.dateKey)],
      sortedAllDays
    );

    if (dayToAdd) {
      selectedDays.push(dayToAdd);
      availableDays = availableDays.filter((d) => d.dateKey !== dayToAdd.dateKey);
    } else if (availableDays.length > 0) {
      // If no day without gap found, just pick the best available (gap filler)
      selectedDays.push(availableDays[0]!);
      availableDays = availableDays.slice(1);
    }
  }

  return selectedDays;
}

/**
 * Find a day from available days that won't create a 4+ day gap.
 */
function findDayWithoutLargeGap(
  availableDays: ScoredDay[],
  plannedRunDateKeys: string[],
  allDays: ScoredDay[]
): ScoredDay | null {
  const MAX_GAP = 3; // Maximum 3 rest days between runs (4-day gap = 4 days without running)

  for (const candidate of availableDays) {
    // Simulate adding this day and check for gaps
    const allRunDates = [...plannedRunDateKeys, candidate.dateKey].sort();

    // Check gaps between consecutive runs
    let hasLargeGap = false;
    for (let i = 0; i < allRunDates.length - 1; i++) {
      const current = new Date(allRunDates[i]!);
      const next = new Date(allRunDates[i + 1]!);
      const daysDiff = Math.floor((next.getTime() - current.getTime()) / (1000 * 60 * 60 * 24));

      if (daysDiff > MAX_GAP + 1) {
        // +1 because consecutive days have diff of 1
        hasLargeGap = true;
        break;
      }
    }

    // Also check gap from first run to start of forecast and last run to end
    if (!hasLargeGap && allDays.length > 0) {
      const firstForecastDay = allDays[0]!;
      const lastForecastDay = allDays[allDays.length - 1]!;
      const sortedRuns = allRunDates.sort();

      if (sortedRuns.length > 0) {
        const firstRunDate = new Date(sortedRuns[0]!);
        const lastRunDate = new Date(sortedRuns[sortedRuns.length - 1]!);

        const gapAtStart = Math.floor(
          (firstRunDate.getTime() - firstForecastDay.date.getTime()) / (1000 * 60 * 60 * 24)
        );
        const gapAtEnd = Math.floor(
          (lastForecastDay.date.getTime() - lastRunDate.getTime()) / (1000 * 60 * 60 * 24)
        );

        if (gapAtStart > MAX_GAP || gapAtEnd > MAX_GAP) {
          hasLargeGap = true;
        }
      }
    }

    if (!hasLargeGap) {
      return candidate;
    }
  }

  return null;
}

/**
 * Generate a human-readable reason for a suggestion.
 */
export function generateReason(
  suggestion: Omit<Suggestion, "reason">,
  scoredDay: ScoredDay,
  isGapFiller: boolean = false
): string {
  const { runType, weatherScore } = suggestion;
  const { weather, quality } = scoredDay;
  const dayName = getDayName(suggestion.date);

  const replacements: Record<string, string | number> = {
    score: weatherScore,
    condition: weather.condition,
    temp: Math.round(weather.temperature),
    precip: Math.round(weather.precipitation),
    windSpeed: Math.round(weather.windSpeed),
    dayName,
  };

  const replace = (template: string): string => {
    return template.replace(/{(\w+)}/g, (_, key) => String(replacements[key] ?? key));
  };

  if (runType === "LONG_RUN") {
    const template = REASON_TEMPLATES.longRun[quality];
    return replace(template);
  }

  // For easy runs and other types
  if (isGapFiller) {
    return replace(REASON_TEMPLATES.easyRun.gapFiller);
  }

  const template = REASON_TEMPLATES.easyRun[quality];
  return replace(template);
}

/**
 * Create a suggestion from a scored day.
 */
function createSuggestion(
  scoredDay: ScoredDay,
  runType: RunType,
  distance: number,
  isGapFiller: boolean = false
): Suggestion {
  const baseSuggestion: Omit<Suggestion, "reason"> = {
    date: scoredDay.date,
    runType,
    distance,
    weatherScore: scoredDay.score,
    isOptimal: scoredDay.score >= 80,
    weather: {
      condition: scoredDay.weather.condition,
      temperature: scoredDay.weather.temperature,
      precipitation: scoredDay.weather.precipitation,
      windSpeed: scoredDay.weather.windSpeed,
    },
  };

  return {
    ...baseSuggestion,
    reason: generateReason(baseSuggestion, scoredDay, isGapFiller),
  };
}

/**
 * Generate optimal run suggestions based on weather and training plan.
 *
 * The algorithm:
 * 1. Determines required runs from training plan
 * 2. Scores all forecast days for weather quality
 * 3. Assigns long run to the best weather day
 * 4. Distributes easy runs across remaining good days
 * 5. Ensures no 4+ day gaps between runs
 * 6. Generates human-readable reasoning for each suggestion
 *
 * @param input - Algorithm input containing forecast, training plan, preferences, and existing runs
 * @returns Array of run suggestions sorted by date
 *
 * @example
 * ```typescript
 * const suggestions = generateSuggestions({
 *   forecast: weatherDataArray,
 *   trainingPlan: { longRunTarget: 16, weeklyMileageTarget: 35, ... },
 *   preferences: weatherPreferencesArray,
 *   existingRuns: [],
 * });
 * ```
 */
export function generateSuggestions(input: AlgorithmInput): Suggestion[] {
  const { forecast, trainingPlan, preferences, existingRuns } = input;

  // Handle edge case: empty forecast
  if (forecast.length === 0) {
    return [];
  }

  // Stage 1: Gather requirements
  const runsNeeded = getRunsNeeded(trainingPlan);

  // Stage 2: Score weather for each day
  const scoredDays = scoreForecastDays(forecast, preferences);

  // Build set of existing run dates for quick lookup
  const existingRunDates = new Set<string>(existingRuns.map((run) => formatDateKey(run.date)));

  const suggestions: Suggestion[] = [];
  const usedDates = new Set<string>();

  // Stage 3: Place long run on best available day
  const longRunDay = findBestLongRunDay(scoredDays, existingRunDates, usedDates);

  if (longRunDay) {
    suggestions.push(createSuggestion(longRunDay, "LONG_RUN", runsNeeded.longRunDistance));
    usedDates.add(longRunDay.dateKey);

    // Mark rest day after long run
    const restDayKey = formatDateKey(addDays(longRunDay.date, 1));
    usedDates.add(restDayKey);
  }

  // Stage 4: Place easy runs on remaining good days
  const longRunDateKey = longRunDay?.dateKey ?? null;
  const easyRunDays = findEasyRunDays(
    scoredDays,
    longRunDateKey,
    existingRunDates,
    usedDates,
    runsNeeded.totalEasyRuns
  );

  for (const easyDay of easyRunDays) {
    // Check if this is a gap filler (placed to prevent 4+ day gap, not for weather)
    const isGapFiller = easyDay.quality === "poor" || easyDay.quality === "fair";
    suggestions.push(
      createSuggestion(easyDay, "EASY_RUN", runsNeeded.easyRunDistance, isGapFiller)
    );
    usedDates.add(easyDay.dateKey);
  }

  // Sort suggestions by date
  suggestions.sort((a, b) => a.date.getTime() - b.date.getTime());

  return suggestions;
}

/**
 * Check if a date falls on a weekend (Saturday or Sunday).
 */
export function isWeekend(date: Date): boolean {
  const day = date.getDay();
  return day === 0 || day === 6;
}

/**
 * Calculate the gap in days between two dates.
 */
export function getDayGap(date1: Date, date2: Date): number {
  const diffTime = Math.abs(date2.getTime() - date1.getTime());
  return Math.floor(diffTime / (1000 * 60 * 60 * 24));
}

/**
 * Validate that suggestions don't have any 4+ day gaps.
 * Utility function for testing and verification.
 */
export function validateNoLargeGaps(suggestions: Suggestion[]): boolean {
  if (suggestions.length <= 1) {
    return true;
  }

  const sortedDates = suggestions.map((s) => s.date).sort((a, b) => a.getTime() - b.getTime());

  for (let i = 0; i < sortedDates.length - 1; i++) {
    const gap = getDayGap(sortedDates[i]!, sortedDates[i + 1]!);
    if (gap > 4) {
      return false;
    }
  }

  return true;
}

/**
 * Validate that no hard days are back-to-back.
 * Hard days: LONG_RUN, TEMPO_RUN, INTERVAL_RUN
 * Utility function for testing and verification.
 */
export function validateNoBackToBackHardDays(suggestions: Suggestion[]): boolean {
  const hardRunTypes: RunType[] = ["LONG_RUN", "TEMPO_RUN", "INTERVAL_RUN"];

  // Sort by date
  const sorted = [...suggestions].sort((a, b) => a.date.getTime() - b.date.getTime());

  for (let i = 0; i < sorted.length - 1; i++) {
    const current = sorted[i]!;
    const next = sorted[i + 1]!;

    // Check if consecutive days
    const gap = getDayGap(current.date, next.date);
    if (gap === 1) {
      // Check if both are hard days
      const currentIsHard = hardRunTypes.includes(current.runType);
      const nextIsHard = hardRunTypes.includes(next.runType);

      if (currentIsHard && nextIsHard) {
        return false;
      }
    }
  }

  return true;
}
