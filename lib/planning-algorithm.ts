/**
 * Planning Algorithm - Core Run Suggestion Generator
 *
 * This module implements the intelligent run suggestion algorithm that is the core
 * value proposition of RainCheck. It takes weather forecasts, training plan requirements,
 * and weather preferences as inputs, then generates optimal run suggestions.
 *
 * Algorithm Rules:
 * 1. Long runs are scheduled on Sunday or Monday (whichever has better weather)
 * 2. Long runs are >= 10km, distance progresses from longest completed run
 * 3. After a long run, 2 rest days are enforced
 * 4. Short runs are always 6km
 * 5. After a short run, 1 rest day is enforced
 * 6. Time window: 10am-3pm for all runs
 * 7. Suggestions start from tomorrow, respecting rest gaps from completed runs
 * 8. New suggestions only appear after the last accepted (scheduled) run
 *
 * @example
 * ```typescript
 * import { generateSuggestions } from '@/lib/planning-algorithm';
 *
 * const suggestions = generateSuggestions({
 *   forecast: weatherData,
 *   trainingPlan: currentWeekPlan,
 *   preferences: weatherPreferences,
 *   existingRuns: [],
 *   acceptedRuns: [],
 *   longestCompletedDistance: 12,
 *   lastCompletedRun: null,
 * });
 * ```
 */

import type { RunType, TrainingPlan, WeatherPreference } from "@prisma/client";
import type { WeatherData, HourlyWeather } from "@/types/weather";
import {
  getWeatherScore,
  toWeatherPreferenceThresholds,
  type WeatherDataForScoring,
} from "./weather-preferences";

// Re-export RunType for convenience
export { RunType } from "@prisma/client";

// Time window constants (10am-3pm for all runs)
const RUN_START_HOUR = 10; // 10am
const RUN_END_HOUR = 15; // 3pm

// Rest day constants
const REST_DAYS_AFTER_LONG_RUN = 2;
const REST_DAYS_AFTER_SHORT_RUN = 1;

// Distance constants
const SHORT_RUN_DISTANCE = 6; // Always 6km
const LONG_RUN_THRESHOLD = 10; // >= 10km is considered a long run
const DEFAULT_FIRST_LONG_RUN_DISTANCE = 10; // Starting distance if no history

/**
 * Accepted run structure for scheduling around existing runs.
 */
export interface AcceptedRun {
  id: string;
  date: Date;
  runType: RunType;
  completed: boolean;
  distance: number;
}

/**
 * Last completed run for calculating rest requirements.
 */
export interface LastCompletedRun {
  date: Date;
  distance: number;
}

/**
 * Input parameters for the planning algorithm.
 */
export interface AlgorithmInput {
  /** Array of daily weather forecasts with hourly data */
  forecast: WeatherData[];
  /** Current week's training plan (optional - algorithm works without it) */
  trainingPlan: TrainingPlan | null;
  /** Weather preferences for each run type */
  preferences: WeatherPreference[];
  /** Already scheduled runs to avoid conflicts (legacy, kept for compatibility) */
  existingRuns: Array<{ date: Date | string; runType: RunType }>;
  /** Accepted runs (scheduled but not completed) */
  acceptedRuns?: AcceptedRun[];
  /** Longest distance from completed runs (for progression) */
  longestCompletedDistance?: number;
  /** Most recent completed run (for rest calculation) */
  lastCompletedRun?: LastCompletedRun | null;
}

/**
 * Time range for a suggested run
 */
export interface TimeRange {
  start: string; // "10am"
  end: string; // "12pm"
}

/**
 * Weather summary included in each suggestion.
 */
export interface WeatherSummary {
  condition: string;
  temperature: number;
  precipitation: number;
  windSpeed: number;
}

/**
 * A run suggestion generated by the algorithm.
 */
export interface Suggestion {
  /** Date for the suggested run */
  date: Date;
  /** IANA timezone for the location, e.g., "Europe/Dublin" */
  timezone: string;
  /** Type of run to do on this day */
  runType: RunType;
  /** Suggested distance in km */
  distance: number;
  /** Weather quality score (0-100) for the suggested time window */
  weatherScore: number;
  /** True if score >= 80 (excellent conditions) */
  isOptimal: boolean;
  /** Human-readable explanation for this suggestion */
  reason: string;
  /** Weather data for the suggested time window */
  weather: WeatherSummary;
  /** Suggested time range for the run */
  timeRange: TimeRange;
}

/**
 * Internal structure for scored time windows.
 */
interface ScoredTimeWindow {
  date: Date;
  timezone: string;
  dateKey: string;
  startHour: number;
  endHour: number;
  score: number;
  weather: WeatherSummary;
}

/**
 * Format a date as YYYY-MM-DD for consistent comparisons.
 */
export function formatDateKey(date: Date | string): string {
  const d = typeof date === "string" ? new Date(date) : date;
  return d.toISOString().split("T")[0]!;
}

/**
 * Add days to a date and return a new Date object.
 */
export function addDays(date: Date, days: number): Date {
  const result = new Date(date);
  result.setDate(result.getDate() + days);
  return result;
}

/**
 * Get the day name for a date.
 */
export function getDayName(date: Date): string {
  const days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
  return days[date.getDay()]!;
}

/**
 * Check if a date is a weekend (Saturday or Sunday).
 */
export function isWeekend(date: Date): boolean {
  const day = date.getDay();
  return day === 0 || day === 6; // 0 = Sunday, 6 = Saturday
}

/**
 * Check if a date is a Sunday.
 */
export function isSunday(date: Date): boolean {
  return date.getDay() === 0;
}

/**
 * Check if a date is a Monday.
 */
export function isMonday(date: Date): boolean {
  return date.getDay() === 1;
}

/**
 * Check if a date is Sunday or Monday (valid long run days).
 */
export function isSundayOrMonday(date: Date): boolean {
  const day = date.getDay();
  return day === 0 || day === 1; // 0 = Sunday, 1 = Monday
}

/**
 * Get the Sunday that starts the week containing the given date.
 */
export function getWeekStart(date: Date): Date {
  const d = new Date(date);
  const day = d.getDay();
  d.setDate(d.getDate() - day);
  d.setHours(0, 0, 0, 0);
  return d;
}

/**
 * Format hour to readable string (e.g., 9 -> "9am", 14 -> "2pm")
 */
export function formatHour(hour: number): string {
  if (hour === 0) return "12am";
  if (hour === 12) return "12pm";
  if (hour < 12) return `${hour}am`;
  return `${hour - 12}pm`;
}

/**
 * Calculate the next long run distance based on progression.
 * Returns floor(longest) + 1, so:
 * - If longest is 13.26km, next is 14km
 * - If longest is 15.0km (already scheduled), next is 16km
 */
export function calculateNextLongRunDistance(longestCompletedDistance: number): number {
  if (longestCompletedDistance === 0 || longestCompletedDistance < LONG_RUN_THRESHOLD) {
    return DEFAULT_FIRST_LONG_RUN_DISTANCE;
  }
  // Use floor + 1 to ensure we always progress beyond the longest existing run
  return Math.floor(longestCompletedDistance) + 1;
}

/**
 * Calculate the start date for new suggestions.
 * Takes into account:
 * - Must be at least tomorrow
 * - Must respect rest days after last completed run
 * - Must be after last accepted (scheduled) run
 */
export function calculateSuggestionStartDate(
  lastCompletedRun: LastCompletedRun | null | undefined,
  acceptedRuns: AcceptedRun[] | undefined
): Date {
  const now = new Date();
  const tomorrow = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);
  tomorrow.setHours(0, 0, 0, 0);

  let startDate = tomorrow;

  // If there are accepted (scheduled but not completed) runs,
  // suggestions start after the last one
  if (acceptedRuns && acceptedRuns.length > 0) {
    const scheduledRuns = acceptedRuns
      .filter((r) => !r.completed)
      .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());

    if (scheduledRuns.length > 0) {
      const lastScheduled = new Date(scheduledRuns[0]!.date);
      lastScheduled.setHours(0, 0, 0, 0);
      const dayAfterLastScheduled = addDays(lastScheduled, 1);
      if (dayAfterLastScheduled > startDate) {
        startDate = dayAfterLastScheduled;
      }
    }
  }

  // Calculate based on rest from last completed run
  if (lastCompletedRun) {
    const restDays =
      lastCompletedRun.distance >= LONG_RUN_THRESHOLD
        ? REST_DAYS_AFTER_LONG_RUN
        : REST_DAYS_AFTER_SHORT_RUN;
    const lastCompletedDate = new Date(lastCompletedRun.date);
    lastCompletedDate.setHours(0, 0, 0, 0);
    const restEndDate = addDays(lastCompletedDate, restDays + 1);
    if (restEndDate > startDate) {
      startDate = restEndDate;
    }
  }

  return startDate;
}

/**
 * Get the weather preference for a specific run type.
 */
function getPreferenceForRunType(
  preferences: WeatherPreference[],
  runType: RunType
): WeatherPreference | undefined {
  return preferences.find((p) => p.runType === runType);
}

/**
 * Score a time window using hourly weather data.
 * Returns the average score for hours in the window.
 */
function scoreTimeWindow(
  hourlyData: HourlyWeather[],
  startHour: number,
  endHour: number,
  preferences: WeatherPreference[],
  runType: RunType
): { score: number; weather: WeatherSummary } {
  const preference = getPreferenceForRunType(preferences, runType);
  const thresholds = preference ? toWeatherPreferenceThresholds(preference) : null;

  // Filter hours within the window
  const windowHours = hourlyData.filter((h) => {
    const hour = h.time.getHours();
    return hour >= startHour && hour < endHour;
  });

  if (windowHours.length === 0) {
    return {
      score: 50,
      weather: { condition: "Unknown", temperature: 10, precipitation: 50, windSpeed: 20 },
    };
  }

  // Calculate average weather for the window
  const avgTemp = windowHours.reduce((sum, h) => sum + h.temperature, 0) / windowHours.length;
  const avgPrecip = windowHours.reduce((sum, h) => sum + h.precipitation, 0) / windowHours.length;
  const avgWind = windowHours.reduce((sum, h) => sum + h.windSpeed, 0) / windowHours.length;
  const avgHumidity = windowHours.reduce((sum, h) => sum + h.humidity, 0) / windowHours.length;

  // Use the most common condition in the window
  const conditionCounts = new Map<string, number>();
  windowHours.forEach((h) => {
    conditionCounts.set(h.condition, (conditionCounts.get(h.condition) || 0) + 1);
  });
  let mostCommonCondition = "Unknown";
  let maxCount = 0;
  conditionCounts.forEach((count, condition) => {
    if (count > maxCount) {
      maxCount = count;
      mostCommonCondition = condition;
    }
  });

  const weatherForScoring: WeatherDataForScoring = {
    condition: mostCommonCondition,
    temperature: avgTemp,
    feelsLike: avgTemp,
    precipitation: avgPrecip,
    humidity: avgHumidity,
    windSpeed: avgWind,
  };

  const score = thresholds ? getWeatherScore(weatherForScoring, thresholds) : 50;

  return {
    score: Math.round(score),
    weather: {
      condition: mostCommonCondition,
      temperature: Math.round(avgTemp),
      precipitation: Math.round(avgPrecip),
      windSpeed: Math.round(avgWind),
    },
  };
}

/**
 * Find the best time window for a run on a given day.
 * Uses 10am-3pm window for all run types.
 */
function findBestTimeWindow(
  dayWeather: WeatherData,
  preferences: WeatherPreference[],
  runType: RunType
): ScoredTimeWindow | null {
  const startHour = RUN_START_HOUR;
  const endHour = RUN_END_HOUR;

  // If no hourly data, use daily data
  if (!dayWeather.hourly || dayWeather.hourly.length === 0) {
    const preference = getPreferenceForRunType(preferences, runType);
    const thresholds = preference ? toWeatherPreferenceThresholds(preference) : null;
    const weatherForScoring: WeatherDataForScoring = {
      condition: dayWeather.condition,
      temperature: dayWeather.temperature,
      feelsLike: dayWeather.feelsLike,
      precipitation: dayWeather.precipitation,
      humidity: dayWeather.humidity,
      windSpeed: dayWeather.windSpeed,
    };
    const score = thresholds ? getWeatherScore(weatherForScoring, thresholds) : 50;

    return {
      date: dayWeather.datetime,
      timezone: dayWeather.timezone,
      dateKey: formatDateKey(dayWeather.datetime),
      startHour,
      endHour,
      score: Math.round(score),
      weather: {
        condition: dayWeather.condition,
        temperature: Math.round(dayWeather.temperature),
        precipitation: Math.round(dayWeather.precipitation),
        windSpeed: Math.round(dayWeather.windSpeed),
      },
    };
  }

  // Try different 2-hour windows within 10am-3pm and find the best
  let bestWindow: ScoredTimeWindow | null = null;
  let bestScore = -1;

  // Window size: 2 hours for short runs, 3 hours for long runs
  const isLongRun = runType === "LONG_RUN";
  const windowSize = isLongRun ? 3 : 2;

  for (let windowStart = startHour; windowStart <= endHour - windowSize; windowStart++) {
    const { score, weather } = scoreTimeWindow(
      dayWeather.hourly,
      windowStart,
      windowStart + windowSize,
      preferences,
      runType
    );

    if (score > bestScore) {
      bestScore = score;
      bestWindow = {
        date: dayWeather.datetime,
        timezone: dayWeather.timezone,
        dateKey: formatDateKey(dayWeather.datetime),
        startHour: windowStart,
        endHour: windowStart + windowSize,
        score,
        weather,
      };
    }
  }

  // If no window found, return full range
  if (!bestWindow) {
    const { score, weather } = scoreTimeWindow(
      dayWeather.hourly,
      startHour,
      endHour,
      preferences,
      runType
    );
    return {
      date: dayWeather.datetime,
      timezone: dayWeather.timezone,
      dateKey: formatDateKey(dayWeather.datetime),
      startHour,
      endHour,
      score,
      weather,
    };
  }

  return bestWindow;
}

/**
 * Generate human-readable reasoning for a suggestion.
 */
function generateReason(runType: RunType, score: number, weather: WeatherSummary): string {
  const quality =
    score >= 80 ? "excellent" : score >= 60 ? "good" : score >= 40 ? "fair" : "challenging";

  if (runType === "LONG_RUN") {
    if (score >= 60) {
      return `Best conditions for your long run (${score}/100). ${weather.condition}, ${weather.temperature}°C with ${weather.precipitation}% precipitation chance.`;
    }
    return `Scheduled based on weather. ${weather.condition} with ${weather.precipitation}% precipitation chance. Consider adjusting pace if needed.`;
  }

  return `${quality.charAt(0).toUpperCase() + quality.slice(1)} conditions (${score}/100). ${weather.condition}, ${weather.temperature}°C.`;
}

/**
 * Create a suggestion from a scored time window.
 */
function createSuggestion(
  window: ScoredTimeWindow,
  runType: RunType,
  distance: number
): Suggestion {
  return {
    date: window.date,
    timezone: window.timezone,
    runType,
    distance,
    weatherScore: window.score,
    isOptimal: window.score >= 80,
    reason: generateReason(runType, window.score, window.weather),
    weather: window.weather,
    timeRange: {
      start: formatHour(window.startHour),
      end: formatHour(window.endHour),
    },
  };
}

/**
 * Generate optimal run suggestions based on weather and training plan.
 *
 * New Algorithm:
 * - Suggestions start from tomorrow, respecting rest gaps
 * - New suggestions appear only after last accepted run
 * - Long runs on Sunday or Monday (best weather between the two)
 * - 2 short runs (6km each) per week, scheduled after long run with proper rest
 * - Long run distance progresses from longest completed run
 */
export function generateSuggestions(input: AlgorithmInput): Suggestion[] {
  const {
    forecast,
    preferences,
    existingRuns,
    acceptedRuns = [],
    longestCompletedDistance = 0,
    lastCompletedRun = null,
  } = input;

  if (forecast.length === 0) {
    return [];
  }

  const suggestions: Suggestion[] = [];
  const usedDates = new Set<string>();
  const restDates = new Set<string>();

  // Step 1: Calculate start date for new suggestions
  const startDate = calculateSuggestionStartDate(lastCompletedRun, acceptedRuns);

  // Step 2: Mark existing run dates and accepted run dates as used
  const existingRunDates = new Set<string>(existingRuns.map((run) => formatDateKey(run.date)));

  // Mark accepted run dates as used and calculate their rest days
  for (const run of acceptedRuns) {
    if (run.completed) continue; // Skip completed runs

    const dateKey = formatDateKey(run.date);
    usedDates.add(dateKey);

    // Mark rest days after accepted runs
    const restDaysNeeded =
      run.distance >= LONG_RUN_THRESHOLD ? REST_DAYS_AFTER_LONG_RUN : REST_DAYS_AFTER_SHORT_RUN;
    for (let i = 1; i <= restDaysNeeded; i++) {
      restDates.add(formatDateKey(addDays(new Date(run.date), i)));
    }
  }

  // Step 3: Schedule short runs after accepted long runs
  // This ensures short runs are generated even when the long run was already accepted
  const acceptedLongRuns = acceptedRuns.filter(
    (run) => !run.completed && run.distance >= LONG_RUN_THRESHOLD
  );

  for (const longRun of acceptedLongRuns) {
    const longRunDate = new Date(longRun.date);

    // First short run: 3 days after long run (2 rest + 1)
    const firstShortDate = addDays(longRunDate, REST_DAYS_AFTER_LONG_RUN + 1);
    const firstShortDateKey = formatDateKey(firstShortDate);

    // Find weather data for first short run date
    const firstShortForecast = forecast.find(
      (d) => formatDateKey(d.datetime) === firstShortDateKey
    );

    if (
      firstShortForecast &&
      !existingRunDates.has(firstShortDateKey) &&
      !usedDates.has(firstShortDateKey) &&
      !restDates.has(firstShortDateKey)
    ) {
      const window = findBestTimeWindow(firstShortForecast, preferences, "EASY_RUN");
      if (window) {
        suggestions.push(createSuggestion(window, "EASY_RUN", SHORT_RUN_DISTANCE));
        usedDates.add(firstShortDateKey);

        // Mark 1 rest day after short run
        restDates.add(formatDateKey(addDays(firstShortDate, REST_DAYS_AFTER_SHORT_RUN)));

        // Second short run: 2 days after first short run (1 rest + 1)
        const secondShortDate = addDays(firstShortDate, REST_DAYS_AFTER_SHORT_RUN + 1);
        const secondShortDateKey = formatDateKey(secondShortDate);

        const secondShortForecast = forecast.find(
          (d) => formatDateKey(d.datetime) === secondShortDateKey
        );

        if (
          secondShortForecast &&
          !existingRunDates.has(secondShortDateKey) &&
          !usedDates.has(secondShortDateKey) &&
          !restDates.has(secondShortDateKey)
        ) {
          const window2 = findBestTimeWindow(secondShortForecast, preferences, "EASY_RUN");
          if (window2) {
            suggestions.push(createSuggestion(window2, "EASY_RUN", SHORT_RUN_DISTANCE));
            usedDates.add(secondShortDateKey);
            restDates.add(formatDateKey(addDays(secondShortDate, REST_DAYS_AFTER_SHORT_RUN)));
          }
        }
      }
    }
  }

  // Step 4: Filter forecast to valid dates (>= startDate)
  const validForecast = forecast.filter((day) => {
    const dayDate = new Date(day.datetime);
    dayDate.setHours(0, 0, 0, 0);
    return dayDate >= startDate;
  });

  if (validForecast.length === 0 && suggestions.length === 0) {
    return [];
  }

  // Step 5: Group forecast days by week (week starts Sunday)
  const weekMap = new Map<string, WeatherData[]>();
  for (const day of validForecast) {
    const weekStart = getWeekStart(day.datetime);
    const weekKey = formatDateKey(weekStart);
    if (!weekMap.has(weekKey)) weekMap.set(weekKey, []);
    weekMap.get(weekKey)!.push(day);
  }

  // Step 5: For each week, schedule 1 long run + 2 short runs
  let longRunDistance = calculateNextLongRunDistance(longestCompletedDistance);

  // Sort weeks chronologically
  const sortedWeeks = Array.from(weekMap.entries()).sort(
    (a, b) => new Date(a[0]).getTime() - new Date(b[0]).getTime()
  );

  for (const [, weekDays] of sortedWeeks) {
    // Find best day for long run (Sunday or Monday only)
    const longRunCandidates = weekDays.filter((day) => {
      const dateKey = formatDateKey(day.datetime);
      return (
        isSundayOrMonday(day.datetime) &&
        !existingRunDates.has(dateKey) &&
        !usedDates.has(dateKey) &&
        !restDates.has(dateKey)
      );
    });

    // Score 10am-3pm window for each candidate
    let bestLongRunDay: WeatherData | null = null;
    let bestLongRunScore = -1;
    let bestLongRunWindow: ScoredTimeWindow | null = null;

    for (const day of longRunCandidates) {
      const window = findBestTimeWindow(day, preferences, "LONG_RUN");
      if (window && window.score > bestLongRunScore) {
        bestLongRunScore = window.score;
        bestLongRunDay = day;
        bestLongRunWindow = window;
      }
    }

    // Schedule long run if found
    if (bestLongRunDay && bestLongRunWindow) {
      const dateKey = formatDateKey(bestLongRunDay.datetime);
      suggestions.push(createSuggestion(bestLongRunWindow, "LONG_RUN", longRunDistance));
      usedDates.add(dateKey);

      // Mark 2 rest days after long run
      for (let i = 1; i <= REST_DAYS_AFTER_LONG_RUN; i++) {
        restDates.add(formatDateKey(addDays(bestLongRunDay.datetime, i)));
      }

      // Increment distance for next long run
      longRunDistance += 1;

      // Schedule 2 short runs after long run
      // First short run: 3 days after long run (2 rest + 1)
      const firstShortDate = addDays(bestLongRunDay.datetime, REST_DAYS_AFTER_LONG_RUN + 1);
      const firstShortDateKey = formatDateKey(firstShortDate);

      // Find weather data for first short run date
      const firstShortForecast = forecast.find(
        (d) => formatDateKey(d.datetime) === firstShortDateKey
      );

      if (
        firstShortForecast &&
        !existingRunDates.has(firstShortDateKey) &&
        !usedDates.has(firstShortDateKey) &&
        !restDates.has(firstShortDateKey)
      ) {
        const window = findBestTimeWindow(firstShortForecast, preferences, "EASY_RUN");
        if (window) {
          suggestions.push(createSuggestion(window, "EASY_RUN", SHORT_RUN_DISTANCE));
          usedDates.add(firstShortDateKey);

          // Mark 1 rest day after short run
          restDates.add(formatDateKey(addDays(firstShortDate, REST_DAYS_AFTER_SHORT_RUN)));

          // Second short run: 2 days after first short run (1 rest + 1)
          const secondShortDate = addDays(firstShortDate, REST_DAYS_AFTER_SHORT_RUN + 1);
          const secondShortDateKey = formatDateKey(secondShortDate);

          const secondShortForecast = forecast.find(
            (d) => formatDateKey(d.datetime) === secondShortDateKey
          );

          if (
            secondShortForecast &&
            !existingRunDates.has(secondShortDateKey) &&
            !usedDates.has(secondShortDateKey) &&
            !restDates.has(secondShortDateKey)
          ) {
            const window2 = findBestTimeWindow(secondShortForecast, preferences, "EASY_RUN");
            if (window2) {
              suggestions.push(createSuggestion(window2, "EASY_RUN", SHORT_RUN_DISTANCE));
              usedDates.add(secondShortDateKey);
              restDates.add(formatDateKey(addDays(secondShortDate, REST_DAYS_AFTER_SHORT_RUN)));
            }
          }
        }
      }
    }
  }

  // Sort suggestions by date
  suggestions.sort((a, b) => a.date.getTime() - b.date.getTime());

  return suggestions;
}

/**
 * Calculate the gap in days between two dates.
 */
export function getDayGap(date1: Date, date2: Date): number {
  const diffTime = Math.abs(date2.getTime() - date1.getTime());
  return Math.floor(diffTime / (1000 * 60 * 60 * 24));
}

/**
 * Validate that no hard days are back-to-back.
 */
export function validateNoBackToBackHardDays(suggestions: Suggestion[]): boolean {
  const hardRunTypes: RunType[] = ["LONG_RUN", "TEMPO_RUN", "INTERVAL_RUN"];
  const sorted = [...suggestions].sort((a, b) => a.date.getTime() - b.date.getTime());

  for (let i = 0; i < sorted.length - 1; i++) {
    const current = sorted[i]!;
    const next = sorted[i + 1]!;
    const gap = getDayGap(current.date, next.date);

    if (gap === 1) {
      const currentIsHard = hardRunTypes.includes(current.runType);
      const nextIsHard = hardRunTypes.includes(next.runType);
      if (currentIsHard && nextIsHard) return false;
    }
  }

  return true;
}

/**
 * Validate that there are no large gaps (5+ days) between suggestions.
 */
export function validateNoLargeGaps(suggestions: Suggestion[]): boolean {
  if (suggestions.length < 2) return true;

  const sorted = [...suggestions].sort((a, b) => a.date.getTime() - b.date.getTime());

  for (let i = 0; i < sorted.length - 1; i++) {
    const current = sorted[i]!;
    const next = sorted[i + 1]!;
    const gap = getDayGap(current.date, next.date);

    if (gap >= 5) return false;
  }

  return true;
}
